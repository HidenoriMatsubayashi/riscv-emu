// Core Local Interruptor (CLINT)
// https://static.dev.sifive.com/FU540-C000-v1.0.pdf

use crate::peripherals::timer::Timer;

pub struct Clint {
    /// current clock cycle.
    cycle: u64,
    // Machine-mode software interrupts are generated by writing to the memory-mapped control register msip.
    // Each msip register is a 32-bit wide WARL register where the upper 31 bits are tied to
    // 0. The least significant bit is reflected in the MSIP bit of the mip CSR. Other bits in the msip
    // registers are hardwired to zero. On reset, each msip register is cleared to zero.
    msip: [u32; 5],

    // mtime is a 64-bit read-write register that contains the number of cycles counted from the RTCCLK
    // input described in Chapter 7. A timer interrupt is pending whenever mtime is greater than or
    // equal to the value in the mtimecmp register. The timer interrupt is reflected in the mtip bit of the
    // mip register described in Chapter 8.
    mtimecmp: [u64; 5],
    mtime: u64,
}

impl Clint {
    pub fn new() -> Self {
        Clint {
            cycle: 0,
            msip: [0; 5],
            mtimecmp: [0; 5],
            mtime: 0,
        }
    }

    pub fn read_mtime(&self) -> u64 {
        self.mtime
    }

    pub fn write_mtime(&mut self, data: u64) {
        self.mtime = data
    }
}

impl Timer for Clint {
    fn tick(&mut self) {
        self.cycle = self.cycle.wrapping_add(1);

        // todo: Correctly care for the clock frequency (1MHz clock @ RTCCLK).
        //if self.cycle % 0xfffff == 0 {
            self.mtime = self.mtime.wrapping_add(1);
        //}
    }

    fn is_pending_software_interrupt(&mut self, core: usize) -> bool {
        self.msip[core] & 0x1 > 0
    }

    fn is_pending_timer_interrupt(&mut self, core: usize) -> bool {
        self.mtimecmp[core] != 0 && self.mtime >= self.mtimecmp[core]
    }

    fn read(&mut self, addr: u64) -> u32 {
        match addr & 0xfffc {
            0x0 => self.msip[0],
            0x4 => self.msip[1],
            0x8 => self.msip[2],
            0xc => self.msip[3],
            0x10 => self.msip[4],
            0x4000 => (self.mtimecmp[0] & 0xffffffff) as u32,
            0x4004 => ((self.mtimecmp[0] >> 32) & 0xffffffff) as u32,
            0x4008 => (self.mtimecmp[1] & 0xffffffff) as u32,
            0x400c => ((self.mtimecmp[1] >> 32) & 0xffffffff) as u32,
            0x4010 => (self.mtimecmp[2] & 0xffffffff) as u32,
            0x4014 => ((self.mtimecmp[2] >> 32) & 0xffffffff) as u32,
            0x4018 => (self.mtimecmp[3] & 0xffffffff) as u32,
            0x401c => ((self.mtimecmp[3] >> 32) & 0xffffffff) as u32,
            0x4020 => (self.mtimecmp[4] & 0xffffffff) as u32,
            0x4024 => ((self.mtimecmp[4] >> 32) & 0xffffffff) as u32,
            0xbff8 => (self.mtime & 0xffffffff) as u32,
            0xbffc => ((self.mtime >> 32) & 0xffffffff) as u32,
            n => panic!("Read reserved address: {:x}", n),
        }
    }

    fn write(&mut self, addr: u64, data: u32) {
        match addr & 0xfffc {
            0x0 => self.msip[0] = data,
            0x4 => self.msip[1] = data,
            0x8 => self.msip[2] = data,
            0xc => self.msip[3] = data,
            0x10 => self.msip[4] = data,
            0x4000 => self.mtimecmp[0] = (self.mtimecmp[0] & 0xffffffff_00000000) | data as u64,
            0x4004 => self.mtimecmp[0] = (self.mtimecmp[0] & 0xffffffff) | ((data as u64) << 32),
            0x4008 => self.mtimecmp[1] = (self.mtimecmp[1] & 0xffffffff_00000000) | data as u64,
            0x400c => self.mtimecmp[1] = (self.mtimecmp[1] & 0xffffffff) | ((data as u64) << 32),
            0x4010 => self.mtimecmp[2] = (self.mtimecmp[2] & 0xffffffff_00000000) | data as u64,
            0x4014 => self.mtimecmp[2] = (self.mtimecmp[2] & 0xffffffff) | ((data as u64) << 32),
            0x4018 => self.mtimecmp[3] = (self.mtimecmp[3] & 0xffffffff_00000000) | data as u64,
            0x401c => self.mtimecmp[3] = (self.mtimecmp[3] & 0xffffffff) | ((data as u64) << 32),
            0x4020 => self.mtimecmp[4] = (self.mtimecmp[4] & 0xffffffff_00000000) | data as u64,
            0x4024 => self.mtimecmp[4] = (self.mtimecmp[4] & 0xffffffff) | ((data as u64) << 32),
            0xbff8 => self.mtime = (self.mtime & 0xffffffff_00000000) | data as u64,
            0xbffc => self.mtime = (self.mtime & 0xffffffff) | ((data as u64) << 32),
            n => panic!("Write reserved address: {:x}", n),
        }
    }
}
